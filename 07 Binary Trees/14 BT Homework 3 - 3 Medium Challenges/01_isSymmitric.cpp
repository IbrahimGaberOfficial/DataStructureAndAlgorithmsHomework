#include <bits\stdc++.h>
using namespace std;

struct TreeNode{
    int val{ };
    TreeNode *left{ };
    TreeNode *right{ };
    TreeNode(int data): val(data){
        // val = data;
    }


};
struct BinaryTree{
    TreeNode *root;

    BinaryTree(int val) : root(new TreeNode(val)){
        
    }
    void print_inorder(TreeNode *current){
        if(!current)
            return;
        print_inorder(current->left);
        cout << current->val << " ";
        print_inorder(current->right);
                
    }
    void add(vector<int> values, vector<char> directions){
        assert(values.size() == directions.size());
        int size = values.size();
        TreeNode *current = this->root;
        for(int i = 0; i < size; i++){
            if(directions[i] == 'L'){
                if(!current->left){
                    current->left = new TreeNode(values[i]);
                    current = current->left;
                }
                else{
                    assert(current->left->val == values[i]);
                    current = current->left;
                }
            }
            else if(directions[i] == 'R'){
                if(!current->right){
                    current->right = new TreeNode(values[i]);
                    current = current->right;
                }
                else{
                    current = current->right;
                }
            }
        }
        
    }
    ////////////////////// 
    bool is_mirror(TreeNode *Left, TreeNode *Right){


        if(!Left && !Right)
            return true;
        if(Left && !Right || Right && !Left || Left->val != Right->val)
            return false;

        bool left_mirror = is_mirror(Left->left, Right->right);
        bool right_mirror = is_mirror(Left->right, Right->left);
        return left_mirror && right_mirror;
    }
    bool isSymmetric(TreeNode *current){
        if(!current)
            return true;
        bool result = is_mirror(current->left, current->right);
        return result;
    }

};


int main(){

BinaryTree myTree(2);
    BinaryTree tree(1);
	tree.add( { 2, 4, 7 }, { 'L', 'L', 'L' });
	tree.add( { 2, 4, 8 }, { 'L', 'L', 'R' });
	tree.add( { 2, 5, 9 }, { 'L', 'R', 'R' });
	tree.add( { 3, 6, 10 }, { 'R', 'R', 'L' });

	cout << myTree.isSymmetric(myTree.root) << "\n";
return 0;
}
